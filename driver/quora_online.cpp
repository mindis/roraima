#include <vector>
#include <fstream>
#include <string>
#include <iostream>
#include <stdexcept>
#include <unordered_map>

#include <google/gflags.h>

#include "utils.hpp"
#include "balltree.hpp"
#include "search.hpp"
#include "cache.hpp"

std::vector<std::vector<double> > get_item_factor(const std::string & fname) {
  std::vector<std::vector<double> > factor_vec_lst;
  std::ifstream f(fname);
  std::string line_buf;
  if(!f) { throw std::runtime_error("roraima error in get_item_factor: loading failed."); }
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    auto tmp2 = roraima::str_split(tmp[1], "|");
    std::vector<double> temp;
    for(auto & fac : tmp2) {
      temp.push_back(std::stod(fac));
    }
    factor_vec_lst.push_back(std::move(temp));
  }
  return factor_vec_lst;
}

std::unordered_map<std::string, long> get_usr_meta_dct(const std::string & fname) {
  std::unordered_map<std::string, long> meta_dct;
  std::ifstream f(fname);
  std::string line_buf;
  if(!f) { throw std::runtime_error("roraima error in get_usr_factor_lst: loading failed."); }
  long offset = 0;
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    meta_dct[tmp[0]] = offset;
    offset = f.tellg();
  }
  f.close();
  return meta_dct;
}

std::unordered_map<long, char> get_heart_trackids(const std::string & fname, const long offset = 0, char sep1 = ':', char sep2 = '|') {
  std::unordered_map<long, char> ids;
  std::ifstream f(fname);
  std::string line_buf;
  f.seekg(offset);
  std::getline(f, line_buf);
  auto tmp = roraima::str_split(line_buf, sep1);
  auto tmp2 = roraima::str_split(tmp[1], sep2);
  for(int i = 1; i < (int)tmp2.size(); ++i) {
    ids[std::stol(tmp2[i])] = '0';
  }
  f.close();
  return ids;
}

std::vector<double> get_usr_factor(const std::string & fname, const long offset = 0, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  f.seekg(offset);
  std::getline(f, line_buf);
  auto tmp = roraima::str_split(line_buf, sep1);
  auto tmp2 = roraima::str_split(tmp[1], sep2);
  factor_vec.push_back(1.);
  for(int i = 1; i < (int)tmp2.size(); ++i) {
    factor_vec.push_back(std::stod(tmp2[i]));
  }
  return factor_vec;
}

std::vector<double> get_usr_factor(const std::string & fname, const std::string & usr_id, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  while(std::getline(f, line_buf)) { 
    auto tmp = roraima::str_split(line_buf, sep1);
    if(tmp[0] == usr_id) {
      auto tmp2 = roraima::str_split(tmp[1], sep2);
      factor_vec.push_back(1.);
      for(int i = 1; i < (int)tmp2.size(); ++i) {
        factor_vec.push_back(std::stod(tmp2[i]));
      }
      break;
    }
  }
  return factor_vec;
}

DEFINE_string(item_factor_file, 
	"/mfs/user/wuhong/Data/fm/factor_100d/new_item_factor.csv", 
	"Item factor file generated by matrix factorization.\n\
	fmt: user_id:user_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_string(usr_factor_file, 
	"/mfs/user/wuhong/Data/fm/factor_100d/new_usr_factor.csv", 
	"User factor file generated by matrix factorization.\n\
	fmt: item_id:item_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_string(usr_heart_file, 
	"/mfs/user/wuhong/tmp/usr_heart_dict.csv",
	"fmt: item_id:item_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_int64(topk, 50, "top k maximum rating(default kernel: inner product).\n");
DEFINE_int64(cache_sz, 10000, "cache size.\n");

int main(int argc, char *argv[]) 
{
  google::SetUsageMessage("[options]\n\
  			--item_factor_file\titem factor\n\
			--usr_factor_file\tuser factor\n\
			--usr_heart_file\tuser heart\n\
			--topk\n\
			--cache_sz\n");
  google::ParseCommandLineFlags(&argc, &argv, true);

  roraima::lru_cache<std::string, std::vector<long> > cache(FLAGS_cache_sz);
  
  std::vector<long> answer;
  auto item_factor_lst = get_item_factor(FLAGS_item_factor_file);
  auto usr_factor_meta_dct = get_usr_meta_dct(FLAGS_usr_factor_file);
  auto usr_heart_meta_dct = get_usr_meta_dct(FLAGS_usr_heart_file);
  roraima::balltree<double, roraima::eculid_dist> stree(item_factor_lst);
  stree.build();
  std::string s;
  std::vector<double> user_factor;
  std::unordered_map<long, char> user_heart_ids;
  while(std::cin >> s) { 
    //auto user_factor = get_usr_factor(FLAGS_usr_factor_file, s);
    if(usr_factor_meta_dct.find(s) != usr_factor_meta_dct.end()) {
      user_factor = get_usr_factor(FLAGS_usr_factor_file, usr_factor_meta_dct[s]);
    } else {
      std::cout << "-1" << std::endl; 
      continue; 
    }
    // load hearted trackid
    if(usr_heart_meta_dct.find(s) != usr_heart_meta_dct.end()) {
      user_heart_ids = get_heart_trackids(FLAGS_usr_heart_file, usr_heart_meta_dct[s]);
    } else {
      // user_heart_ids is empty
    }

    roraima::query q(user_heart_ids, user_factor, FLAGS_topk);
    answer = cache.Get(s);
    if(!answer.size()) {
      roraima::search(q, stree, answer);
    } else {}
    cache.Put(s, answer);
    for(auto & indx : answer)
      std::cout << indx << std::endl;
  }
  return 0;
}
