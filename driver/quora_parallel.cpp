#include <vector>
#include <fstream>
#include <string>
#include <iostream>
#include <stdexcept>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <mpi.h>
#include <google/gflags.h>

#include "utils.hpp"
#include "balltree.hpp"
#include "search.hpp"
#include "cache.hpp"

std::vector<std::vector<double> > get_item_factor(const std::string & fname) {
  std::vector<std::vector<double> > factor_vec_lst;
  std::ifstream f(fname);
  std::string line_buf;
  if(!f) { throw std::runtime_error("roraima error in get_item_factor: loading failed."); }
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    auto tmp2 = roraima::str_split(tmp[1], "|");
    std::vector<double> temp;
    for(auto & fac : tmp2) {
      temp.push_back(std::stod(fac));
    }
    factor_vec_lst.push_back(std::move(temp));
  }
  return factor_vec_lst;
}

std::vector<double> get_usr_factor(const std::string & fname, const int offset = 0, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  int cnt = 0;
  while(std::getline(f, line_buf) and cnt < offset) { cnt += 1; }
  auto tmp = roraima::str_split(line_buf, sep1);
  auto tmp2 = roraima::str_split(tmp[1], sep2);
  factor_vec.push_back(1.);
  for(int i = 1; i < (int)tmp2.size(); ++i) {
    factor_vec.push_back(std::stod(tmp2[i]));
  }
  return factor_vec;
}

std::vector<double> get_usr_factor(const std::string & fname, const std::string & usr_id, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  while(std::getline(f, line_buf)) { 
    auto tmp = roraima::str_split(line_buf, sep1);
    if(tmp[0] == usr_id) {
      auto tmp2 = roraima::str_split(tmp[1], sep2);
      factor_vec.push_back(1.);
      for(int i = 1; i < (int)tmp2.size(); ++i) {
        factor_vec.push_back(std::stod(tmp2[i]));
      }
      break;
    }
  }
  return factor_vec;
}

/* offset in offsets is different */
std::vector<std::vector<double> > get_usr_factors(const std::string & fname, const std::vector<int> & offsets, char sep1 = ':', char sep2 = '|') {
  std::vector<std::vector<double> > factor_vec_lst(offsets.size());
  for(int i = 0; i < (int)offsets.size(); ++i) {
    factor_vec_lst[i] = get_usr_factor(fname, offsets[i], sep1, sep2);
  }
  return factor_vec_lst;
}

/* id in usr_id os different */
std::vector<std::vector<double> > get_usr_factors(const std::string & fname, const std::vector<std::string> & usr_ids, char sep1 = ':', char sep2 = '|') {
  std::vector<std::vector<double> > factor_vec_lst(usr_ids.size());
  for(int i = 0; i < (int)usr_ids.size(); ++i) {
    factor_vec_lst[i] = get_usr_factor(fname, usr_ids[i], sep1, sep2);
  }
  return factor_vec_lst;
}

std::string random_functor() { return std::to_string(std::rand() % 100 + 1); }

void filter(const std::vector<std::string> & qs,
	std::map<std::string, std::vector<std::size_t> > & m) {
  for(std::size_t i = 0; i < qs.size(); ++ i) {
    m[qs[i]].push_back(i); 
  }
}

DEFINE_string(item_factor_file, 
	"/home/xunzhang/xunzhang/Proj/parasol/tests/serial_mf/item_factor.csv", 
	"Item factor file generated by matrix factorization.\n\
	fmt: user_id:user_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_string(usr_factor_file, 
	"/home/xunzhang/xunzhang/Proj/parasol/tests/serial_mf/usr_factor.csv", 
	"User factor file generated by matrix factorization.\n\
	fmt: item_id:item_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_int64(topk, 10, "top k maximum rating(default kernel: inner product).\n");
DEFINE_int64(cache_sz, 10, "cache size.\n");

int main(int argc, char *argv[]) 
{
  google::SetUsageMessage("[options]\n\
  			--item_factor_file\titem factor\n\
			--usr_factor_file\tuser factor\n\
			--topk\n\
			--cache_sz\n");
  google::ParseCommandLineFlags(&argc, &argv, true);
  
  int rk, sz;
  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD, &rk);
  MPI_Comm_size(MPI_COMM_WORLD, &sz);
  
  roraima::lru_cache<std::string, std::vector<std::size_t> > cache(FLAGS_cache_sz);

  std::vector<std::string> mock_questions(100);
  mock_questions[0] = "1";
  mock_questions[1] = "7";
  mock_questions[2] = "1";
  mock_questions[3] = "3";
  mock_questions[4] = "1";
  std::generate(mock_questions.begin() + 5, mock_questions.end(), random_functor);

  std::map<std::string, std::vector<std::size_t> > map;
  filter(mock_questions, map);

  int l = map.size() / sz;
  int start = rk * l;
  int end = 0;
  if(rk != sz - 1) {
    end = (rk + 1) * l - 1;
  } else {
    end = sz - 1;
  }
  std::map<std::string, std::vector<std::size_t> > local_map(map.begin(), map.end());

  std::vector<std::size_t> answer;
  auto item_factor_lst = get_item_factor(FLAGS_item_factor_file);
  roraima::balltree<double, roraima::eculid_dist> stree(item_factor_lst);
  stree.build();
  
  for(auto & s : mock_questions) {
    int cnt = 0;
    auto user_factor = get_usr_factor(FLAGS_usr_factor_file, s);
    roraima::query q(user_factor, FLAGS_topk);
    answer = cache.Get(s);
    if(!answer.size()) {
      std::cout << "cache miss" << std::endl;
      cnt = roraima::search(q, stree, answer);
    } else {
      std::cout << "cache hit" << std::endl;
    }
    cache.Put(s, answer);
    auto debug = cache.Get(s);
    std::cout << "span cnt: " << cnt << " out of " << item_factor_lst.size() << std::endl;
    //for(auto & indx : answer)
    //  std::cout << indx << std::endl;
  }
  MPI_Finalize();
  return 0;
}
