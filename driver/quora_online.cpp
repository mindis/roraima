#include <vector>
#include <fstream>
#include <string>
#include <iostream>
#include <stdexcept>
#include <unordered_map>
#include <algorithm>

#include <google/gflags.h>

#include "utils.hpp"
#include "balltree.hpp"
#include "search.hpp"
#include "cache.hpp"

std::vector<std::vector<double> > get_item_factor(const std::string & fname) {
  std::vector<std::vector<double> > factor_vec_lst;
  std::ifstream f(fname);
  std::string line_buf;
  if(!f) { throw std::runtime_error("roraima error in get_item_factor: loading failed."); }
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    auto tmp2 = roraima::str_split(tmp[1], "|");
    std::vector<double> temp;
    for(auto & fac : tmp2) {
      temp.push_back(std::stod(fac));
    }
    factor_vec_lst.push_back(std::move(temp));
  }
  f.close();
  return factor_vec_lst;
}

void get_item_indices_and_top_ibias_ids(const std::string & fname,
			std::unordered_map<long, long> & indices_dct,
			std::unordered_map<long, long> & reverse_indices_dct,
			std::vector<long> & top_ibias_ids, int topk) {
  std::ifstream f(fname);
  std::string line_buf;
  vector<std::pair<long, double> > d;
  if(!f) { throw std::runtime_error("roraima error in get_item_indices_and_bias: loading failed,"); }
  long cnt = 0;
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    auto tmp2 = roraima::str_split(tmp[1], "|");
    indices_dct[cnt] = std::stol(tmp[0]);
    reverse_indices_dct[std::stol(tmp[0])] = cnt;
    d.push_back(std::pair<long, double>(std::stol(tmp[0]), std::stod(tmp2[0])));
    cnt += 1;
  }
  std::sort(d.begin(), d.end(),
    [] (std::pair<long, double> a,
    std::pair<long, double> b) {
    return a.second > b.second;
  });
  for(auto & kv : d) {
    top_ibias_ids.push_back(kv.first);
    if((int)top_ibias_ids.size() == topk) break;
  }
  f.close();
}

std::unordered_map<std::string, long> get_usr_meta_dct(const std::string & fname) {
  std::unordered_map<std::string, long> meta_dct;
  std::ifstream f(fname);
  std::string line_buf;
  if(!f) { throw std::runtime_error("roraima error in get_usr_factor_lst: loading failed."); }
  long offset = 0;
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    meta_dct[tmp[0]] = offset;
    offset = f.tellg();
  }
  f.close();
  return meta_dct;
}

std::unordered_map<long, char> get_heart_trackids(const std::string & fname, std::unordered_map<long, long> & d, const long offset = 0, char sep1 = ':', char sep2 = '|') {
  std::unordered_map<long, char> ids;
  std::ifstream f(fname);
  std::string line_buf;
  f.seekg(offset);
  std::getline(f, line_buf);
  auto tmp = roraima::str_split(line_buf, sep1);
  auto tmp2 = roraima::str_split(tmp[1], sep2);
  for(int i = 1; i < (int)tmp2.size(); ++i) {
    ids[d[std::stol(tmp2[i])]] = '0';
  }
  f.close();
  return ids;
}

std::vector<double> get_usr_factor(const std::string & fname, const long offset = 0, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  f.seekg(offset);
  std::getline(f, line_buf);
  auto tmp = roraima::str_split(line_buf, sep1);
  auto tmp2 = roraima::str_split(tmp[1], sep2);
  factor_vec.push_back(1.);
  for(int i = 1; i < (int)tmp2.size(); ++i) {
    factor_vec.push_back(std::stod(tmp2[i]));
  }
  return factor_vec;
}

std::vector<double> get_usr_factor(const std::string & fname, const std::string & usr_id, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  while(std::getline(f, line_buf)) { 
    auto tmp = roraima::str_split(line_buf, sep1);
    if(tmp[0] == usr_id) {
      auto tmp2 = roraima::str_split(tmp[1], sep2);
      factor_vec.push_back(1.);
      for(int i = 1; i < (int)tmp2.size(); ++i) {
        factor_vec.push_back(std::stod(tmp2[i]));
      }
      break;
    }
  }
  return factor_vec;
}

DEFINE_string(item_factor_file, 
	"/mfs/user/wuhong/Data/fm/factor_100d/new_item_factor.csv", 
	"Item factor file generated by matrix factorization.\n\
	fmt: user_id:user_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_string(usr_factor_file, 
	"/mfs/user/wuhong/Data/fm/factor_100d/new_usr_factor.csv", 
	"User factor file generated by matrix factorization.\n\
	fmt: item_id:item_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_string(usr_heart_file, 
	"/mfs/user/wuhong/tmp/usr_heart_dict.csv",
	"fmt: item_id:item_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_int64(topk, 50, "top k maximum rating(default kernel: inner product).\n");
DEFINE_int64(cache_sz, 10000, "cache size.\n");

int main(int argc, char *argv[]) 
{
  google::SetUsageMessage("[options]\n\
  			--item_factor_file\titem factor\n\
			--usr_factor_file\tuser factor\n\
			--usr_heart_file\tuser heart\n\
			--topk\n\
			--cache_sz\n");
  google::ParseCommandLineFlags(&argc, &argv, true);

  roraima::lru_cache<std::string, std::vector<long> > cache(FLAGS_cache_sz);
  
  std::vector<long> answer;
  auto item_factor_lst = get_item_factor(FLAGS_item_factor_file);

  std::unordered_map<long, long> item_indices_dct, reverse_item_indices_dct;
  std::vector<long> top_ibias_ids; 
  get_item_indices_and_top_ibias_ids(FLAGS_item_factor_file, item_indices_dct, reverse_item_indices_dct, top_ibias_ids, FLAGS_topk);

  auto usr_factor_meta_dct = get_usr_meta_dct(FLAGS_usr_factor_file);
  auto usr_heart_meta_dct = get_usr_meta_dct(FLAGS_usr_heart_file);
  roraima::balltree<double, roraima::eculid_dist> stree(item_factor_lst);
  stree.build();
  std::string s;
  std::vector<double> user_factor;
  std::unordered_map<long, char> user_heart_ids;
  while(std::cin >> s) { 
    //auto user_factor = get_usr_factor(FLAGS_usr_factor_file, s);
    if(usr_factor_meta_dct.find(s) != usr_factor_meta_dct.end()) {
      user_factor = get_usr_factor(FLAGS_usr_factor_file, usr_factor_meta_dct[s]);
    } else {
      //std::cout << "-1" << std::endl;
      // sort by item_bias to cout topk
      for(auto & indx : top_ibias_ids)
        std::cout << indx << std::endl;
      continue; 
    }
    // load hearted trackid
    if(usr_heart_meta_dct.find(s) != usr_heart_meta_dct.end()) {
      user_heart_ids = get_heart_trackids(FLAGS_usr_heart_file, reverse_item_indices_dct, usr_heart_meta_dct[s]);
    } else {
      // user_heart_ids is empty
    }
    roraima::query q(user_heart_ids, user_factor, FLAGS_topk);
    answer = cache.Get(s);
    if(!answer.size()) {
      roraima::search(q, stree, answer);
    } else {}
    cache.Put(s, answer);
    for(auto & indx : answer)
      std::cout << item_indices_dct[indx] << std::endl;
  }
  return 0;
}
