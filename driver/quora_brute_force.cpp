#include <vector>
#include <fstream>
#include <string>
#include <iostream>
#include <stdexcept>

#include <google/gflags.h>

#include "utils.hpp"
#include "balltree.hpp"
#include "search.hpp"
#include "cache.hpp"

std::vector<long> get_item_indices(const std::string & fname) {
  std::vector<long> ids;
  std::ifstream f(fname);
  std::string line_buf;
  if(!f) { throw std::runtime_error("roraima error in get_item_factor: loading failed."); }
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    ids.push_back(std::stol(tmp[0]));
  }
  return ids;
}

std::vector<std::vector<double> > get_item_factor(const std::string & fname) {
  std::vector<std::vector<double> > factor_vec_lst;
  std::ifstream f(fname);
  std::string line_buf;
  if(!f) { throw std::runtime_error("roraima error in get_item_factor: loading failed."); }
  while(std::getline(f, line_buf)) {
    auto tmp = roraima::str_split(line_buf, ":");
    auto tmp2 = roraima::str_split(tmp[1], "|");
    std::vector<double> temp;
    for(auto & fac : tmp2) {
      temp.push_back(std::stod(fac));
    }
    factor_vec_lst.push_back(std::move(temp));
  }
  return factor_vec_lst;
}

std::vector<double> get_usr_factor(const std::string & fname, const int offset = 0, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  int cnt = 0;
  while(std::getline(f, line_buf) and cnt < offset) { cnt += 1; }
  auto tmp = roraima::str_split(line_buf, sep1);
  auto tmp2 = roraima::str_split(tmp[1], sep2);
  factor_vec.push_back(1.);
  for(int i = 1; i < (int)tmp2.size(); ++i) {
    factor_vec.push_back(std::stod(tmp2[i]));
  }
  return factor_vec;
}

std::vector<double> get_usr_factor(const std::string & fname, const std::string & usr_id, char sep1 = ':', char sep2 = '|') {
  std::vector<double> factor_vec;
  std::ifstream f(fname);
  std::string line_buf;
  while(std::getline(f, line_buf)) { 
    auto tmp = roraima::str_split(line_buf, sep1);
    if(tmp[0] == usr_id) {
      auto tmp2 = roraima::str_split(tmp[1], sep2);
      factor_vec.push_back(1.);
      for(int i = 1; i < (int)tmp2.size(); ++i) {
        factor_vec.push_back(std::stod(tmp2[i]));
      }
      break;
    }
  }
  return factor_vec;
}

DEFINE_string(item_factor_file, 
	"/mfs/user/wuhong/Data/fm/factor_100d/item_factor.csv", 
	"Item factor file generated by matrix factorization.\n\
	fmt: user_id:user_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_string(usr_factor_file, 
	"/mfs/user/wuhong/Data/fm/factor_100d/usr_factor.csv", 
	"User factor file generated by matrix factorization.\n\
	fmt: item_id:item_bias|fac_val_1|fac_val_2|...|fac_val_k.\n\
	':' and '|' can be replaced by sep1, sep2\n");
DEFINE_int64(topk, 50, "top k maximum rating(default kernel: inner product).\n");
DEFINE_int64(cache_sz, 10000, "cache size.\n");

int main(int argc, char *argv[]) 
{
  google::SetUsageMessage("[options]\n\
  			--item_factor_file\titem factor\n\
			--usr_factor_file\tuser factor\n\
			--topk\n\
			--cache_sz\n");
  google::ParseCommandLineFlags(&argc, &argv, true);

  roraima::lru_cache<std::string, std::vector<long> > cache(FLAGS_cache_sz);

  std::vector<long> answer;
  auto item_factor_lst = get_item_factor(FLAGS_item_factor_file);
  auto item_indices = get_item_indices(FLAGS_item_factor_file);
  
  std::string s;
  while(std::cin >> s) { 
    auto user_factor = get_usr_factor(FLAGS_usr_factor_file, s);
    roraima::query q(user_factor, FLAGS_topk);
    answer = cache.Get(s);
    if(!answer.size()) {
      roraima::search(q, item_factor_lst, item_indices, answer);
    } else {}
    for(auto & indx : answer)
      std::cout << indx << std::endl;
  }
  return 0;
}
